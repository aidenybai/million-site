{"/":{"title":"Home","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, render } from 'million';\n\nlet seconds = 0;\n\nsetInterval(() => {\n  render(document.body, m('p', undefined, [`Time elapsed: ${seconds}`]));\n  seconds++;\n}, 1000);\n\n\nrender() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the parent DOM reference, and the second one is a Virtual DOM to render.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/vnode/delta":{"title":"Delta","data":{"":"Syntax: Delta.OPERATION(index)\nExample: Delta.INSERT(0)Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the VNode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [\n  Delta.INSERT(0),\n  Delta.UPDATE(0),\n]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/api/vnode/m":{"title":"m()","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\nThe tagName is stored under the tag, attributes and properties are stored under props, and the children are stored under children.","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","classname-and-style-props-helpers#className and style props helpers":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are handled by default, but sometimes you need to attach SVG namespaces. SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","tovnode-ssr-helper#toVNode SSR helper":"The toVNode function converts an HTMLElement or Text or HTML string to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\n// HTML string\nconst vnode1 = toVNode('<div>Hello World</div>'); // holds <div>Hello World</div> in VNode form\n\n// HTMLElement\nconst el = document.createElement('div');\nel.textContent = 'Hello World';\nconst vnode2 = toVNode(el); // holds <div>Hello World</div> in VNode form\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/api/vnode/entity":{"title":"entity()","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a VNode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst customEntity = entity(data, () =>\n  m('div', { id: 'app' }, [data.message]),\n);\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/api/render/schedule":{"title":"schedule()","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, diff, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/crash-course":{"title":"Crash Course","data":{"":"\nThis page is still in construction. For now, please refer to the API\nreference.\n"}},"/benchmarks":{"title":"Benchmarks","data":{"":"\n\n"}},"/blog/research":{"title":"Research","data":{"":"","less-than-1kb-compiler-augmented-virtual-dom-its-fast#Less-than-1kb compiler-augmented virtual DOM. It's fast!":"Current Virtual DOM implementations are inadequate—Ranging from overcomplicated to abandoned, most are unusable without sacrificing raw performance and size. Million aims to fix this, providing a library-agnostic Virtual DOM to serve as the core for Javascript libraries that focus on precompilation and static analysis.","project-assets#Project Assets":"\nDocumentation\nGitHub\nResearch Paper\nConference Slides\nBenchmarker\nVideo\n\n","presentation#Presentation":"\n\n"}},"/blog/manifesto":{"title":"Manifesto","data":{"":"","past#Past":"Back in the days when JavaScript was first manifested, direct DOM manipulation was used to introduce interactivity for static web sites. Eventually, the JavaScript scene moved on to new technologies such as MooTools and jQuery, which helped simplify certain actions into simple, reusable functions. However, there was still one pressing issue.Even though web development became easier, scaling large web applications that required an extensive amount of interactivity was difficult, as operations were generally imperative and difficult to organize. This led the rise to several frameworks and libraries, notably React. React aimed to allow for declarative development and componentization to compose user interfaces scalably. To achieve this, the team behind React used a Virtual DOM architecture, where computation and logic was deferred to an algorithm to determine changes. This means that the developer just has to figure out how the markup will look.React helped to pioneer extensive usage of JavaScript to render web applications, leading to the rise of the Virtual DOM architecture in other libraries and usage of new technologies like JSX.","present#Present":"Nowadays, the prevalence of web applications is non-negligible. JavaScript and React are everywhere, and the Virtual DOM architecture is used in many of the popular libraries today (React.js, Vue.js, Preact.js, Elm, etc). \"Pure JavaScript rendering\" has subsided as development of preprocessors such as Webpack have taken hold as a standard, leading the way to preprocessors, allowing for cross-browser compatibility (e.g. Babel), prerendering, and JAMstack technologies.JavaScript frameworks and libraries have entire ecosystems around them, with tools like Next.js around React supercharging how web development is done. Library developers are slowly realizing the importance of performance sacrificed in the previous generation of developers for the purpose of developer experience. This is seen with trends towards static analysis with Svelte, which currently leverages the prevalent usage of bundlers in most web applications.Performance is slowly becoming a priority, but technologies that depend on the Virtual DOM like React are fundamentally outdated, even with incremental improvements with lazy loading and ISR in Next.js.","future#Future":"It is easy to to recite, reinvent, and monkey-patch what exists. With React and the Virtual DOM being such a backbone technology in the JavaScript library space, it is paramount that bleeding-edge libraries like Next.js leverage their position in the ecosystem to pioneer compiler-based optimizations. While the most straightforward solution is to ditch everything and use the browser just as compile target with a series of imperative operations, the Virtual DOM arguably brings many advantages. It helps us write declarative interfaces without templating, meaning conditions are constrained to the limit of JavaScript, as well as many other benefits.The future of the Virtual DOM is not destruction of the Virtual DOM, rather it is to constrain usage of the Virtual DOM where it is powerful while leveraging static analysis and compilation (This is done through Million.js).→ Interested in how Million is different?\nI recently had the opportunity to chat with @rauchg about Million.js as well as some of my thoughts on the current state of Virtual DOM. He explained to me that optimization of the Virtual DOM was only a facet of the next phase of web frameworks. This includes how we can improve development mode experience, tree-shaking and bundle size, etc.\naggressive tree shaking - reduce bundle size. I highly recommend you to check out his Twitter and blog, as he has so much valuable insight into the industry and how impact can and needs to be made.\n"}},"/blog/virtual-dom":{"title":"Virtual DOM","data":{"":"","introduction#Introduction":"The virtual DOM is a tree of virtual nodes that represents what the DOM looks like. Virtual nodes are light, stateless, and are strings or JavaScript objects that only contain necessary fields. Virtual nodes can be assembled into trees, and \"diffed\" to make pinpoint changes to the DOM.The reasoning behind this is because modification and access of DOM nodes is computationally expensive. A diff between virtual nodes, accessing the DOM only for modification, is the premise of virtual DOM. It avoids the DOM as much as possible, favoring plain JavaScript objects instead, making reading and writing much cheaper.","how-does-it-work#How does it work?":"The Million virtual DOM contains three main functions: m, createElement, patch. To completely understand how virtual DOM works, let's try and create our own rudimentary virtual DOM based off of these functions (~7 minutes read time).Before we start, we need to define what a virtual node is. A virtual node can either be a JavaScript object (virtual element) or a string (text).The m function is a helper function that creates virtual elements. A virtual element contains three properties:\ntag: which stores the tag name of the element as a string.\nprops: which stores the properties/attributes of the element as an object.\nchildren: which stores virtual node children of the element as an array.\n\nAn example implementation of the m helper function is below:\nconst m = (tag, props = {}, children = []) => ({\n  tag,\n  props,\n  children,\n});\nThis way, we can construct virtual elements easily:\nm('div', { id: 'app' }, ['Hello World']);\n// Is the same as:\n{\n  tag: 'div',\n  props: { id: 'app' },\n  children: ['Hello World']\n}\nThe createElement function turns a virtual node into a real DOM element. This is important because we'll be using this in our patch function and the user may also use it to initialize their application.We'll need to programmatically create a new detached DOM element, then iterate over the virtual element props while adding them to the DOM element, and finally iterating over the children, initializing them as well. An example implementation of the createElement helper function is below:\nconst createElement = (vnode) => {\n  if (typeof vnode === 'string') return document.createTextNode(vnode);\n\n  const el = document.createElement(vnode.tag);\n\n  for (const propName in vnode.props) {\n    el[propName] = vnode.props[propName];\n  }\n\n  for (const child of vnode.children) {\n    el.appendChild(createElement(child));\n  }\n\n  return el;\n};\nThis way, we can convert virtual nodes to DOM elements easily:\ncreateElement(m('div', { id: 'app' }, ['Hello World']));\n// Is the same as: <div id=\"app\">Hello World</div>\nThe patch function takes an existing DOM element, old virtual node, and new virtual node. This won't necessarily be the most performant implementation, but this is just for demonstration purposes.We'll need to diff the two virtual nodes, then replace out the element when needed. We do this by first determining whether one of the virtual nodes is a text, or a string, and replacing it if the old and new virtual nodes do not equate each other. Otherwise, we can safely assume both are virtual elements. After that, we diff the tag and props, and replace the element if the tag has changed. We then iterate over the children and recursively patch if a child is a virtual element. An example implementation of the patch helper function is below:\nconst patch = (el, newVNode, oldVNode) => {\n  if (!newVNode && newVNode !== '') return el.remove();\n  if (typeof oldVNode === 'string' || typeof newVNode === 'string') {\n    if (oldVNode !== newVNode) return el.replaceWith(createElement(newVNode));\n  } else {\n    if (oldVNode?.tag !== newVNode.tag) {\n      return el.replaceWith(createElement(newVNode));\n    }\n\n    if (oldVNode) {\n      for (const propName in oldVNode.props) {\n        if (oldVNode.props[propName] === newVNode.props[propName])\n          return el.replaceWith(createElement(newVNode));\n      }\n\n      for (let i = el.childNodes.length - 1; i >= 0; i--) {\n        patch(el.childNodes[i], newVNode.children[i], oldVNode.children[i]);\n      }\n    }\n  }\n};\nThis way, we can patch DOM elements based on virtual nodes easily:\nconst oldVNode = m('div', { id: 'app' }, ['Hello World']);\nconst newVNode = m('div', { id: 'app' }, ['Goodbye World']);\nconst el = createElement(oldVNode);\n// <div id=\"app\">Hello World</div>\n\npatch(el, oldVNode, newVNode);\n// el will become: <div id=\"app\">Goodbye World</div>\nNotes:\nThe old virtual node must always model the DOM element until after it is patched.\nGenerally speaking, applications aren't directly written with these methods, rather they should be abstracted out into components and JSX for simplicity.\nThis is not the same as Million's implementation, rather it is a demonstration to better allow you to understand how the virtual DOM works.\n\n","so-whats-unique-about-million-then#So... What's unique about Million then?":"Million provides many major improvements: granular patching, fewer iterative passes, fast text interpolation, keyed virtual nodes, compiler flags, deltas, batching, and scheduling.\nGranular patching: Instead of just replacing the entire element when there is a difference in props or children, only the necessary props are changed.\nFewer iterative passes: Million attempts to reduce the amount of passes during diffing, allowing for better time and space complexity.\nFast text interpolation: Instead of replacing text nodes with DOM methods, Million uses compiler flags to set the textContent of elements to boost performance.\nKeyed virtual elements: This allows for the patching algorithm to skip nodes if the new virtual element key is the same as the old one, minimizing the amount of unnecessary work.\nCompiler Flags: This allows for the patching algorithm to skip condition branches, meaning less work is done.\nDeltas: Microactions can be preprogrammed to skip diffing children all together, resulting in a better time complexity and while being easily leveraged by a compiler.\nBatching & Scheduling: Batching together DOM manipulations is baked in by default, and task scheduling is composable for your own uses.\n\n"}},"/docs/api/render/render":{"title":"render()","data":{"":"Syntax: render(parentElement, vnode)\nExample: render(document.body, m('div'), m('div', undefined, ['Hello World']))The render function is a combonation of the patch() and createElement() functions. It takes a parent element and a vnode and returns a DOM node, and renders the vnode into the DOM.\nIf you're seeking more fine grained modification and customization, check out\nthe patch() function.\nHere's an example Counter app using render():\nimport { m, render } from 'million';\n\nlet seconds = 0;\n\nsetInterval(() => {\n  render(document.body, m('p', undefined, [`Time elapsed: ${seconds}`]));\n  seconds++;\n}, 1000);\n\n\nrender() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the parent DOM reference, and the second one is a Virtual DOM to render.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/render/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVNode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","commit--effects#Commit & effects":"Sometimes, we want to do apply our own functionality across the entire VNode tree, yet we want to keep the API usage very simple. There are two areas where you can do this:\nVNode-by-VNode diffing: You can pass a callback into the commit parameter (see patch) syntax to deal with each VNode (excluding special diffing). You can construct a commit callback like this:\npatch(el, newVNode, oldVNode, [], (callback, data) => callback());\nYou can now access the callback, which you execute, and the data to get the context of the execution.\nOperation-by-Operation patching: Once diffing is completed, you can deal with effects, or DOM operations. Normally, effects are batched all at once, but if you want to modify this, you can check out custom patch functions. If you want to add your own custom effects, you can pass callbacks into the effects parameter like this:\npatch(el, newVNode, oldVNode, [() => console.log('Hello World!')]);\n\n\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport { m, useNode, useChildren, useProps, createElement } from 'million';\n\nconst diff = useNode([useChildren(), useProps()]);\n\nconst customPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\ncustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an implementation of a rudimentary virtual DOM with reference-based diffing of an existing el.\nimport { createElement } from 'million';\n\nconst useNodeReplace =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n    const data = {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n\n    commit(() => {\n      if (!newVNode) {\n        effects.push(() => el.remove());\n      } else if (oldVNode !== newVNode) {\n        effects.push(() => el.replaceWith(createElement(newVNode)));\n      }\n    }, data);\n\n    return data;\n  };\n"}},"/docs/api/render/createElement":{"title":"createElement()","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/guide":{"title":"Guide","data":{"":"\nThis page is still in construction. For now, please refer to the API\nreference.\n"}},"/docs/advanced/using-jsx":{"title":"Using JSX","data":{"":"The following declaration style:\nconst HelloWorld = <p>Hello World</p>;\nis called JSX, and it is a syntax extension to JavaScript. Much like React, you can use JSX with Million.js to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces Million VNodes. Below, you can find how to integrate JSX in your own project.","babel#Babel":"\nWe recommend using the\nbabel-preset-million preset with Babel for\nJSX transforms. Babel can easily be used with other bundlers like Webpack, Parcel, or Rollup, or\nstandalone.\nAlternatively, you can manually configure your JSX transform using @babel/plugin-transform-react-jsx.There are two main ways to transform your data, so choose the one that fits your project best.","automatic-runtime-recommended#Automatic runtime (recommended)":"Million.js provides an automatic JSX transform option through under million/jsx-runtime. Babel, by default, uses classic runtime, so you will need to explicitly state that you want automatic runtime. Additionally, you will need to specify an import source. It is not necessary to explicity import million/jsx-runtime with the automatic runtime.index.jsx\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"automatic\",\n        \"importSource\": \"million\"\n      }\n    ]\n  ]\n}\n","classic-runtime#Classic runtime":"If the automatic runtime does not work for you, or you want more fine-grained control, you should use the classic runtime. You'll need to define the pragma and pragmaFrag fields with the imports from the million/jsx-runtime, as shown below.\nThis is often more cumbersome, as you'll need to import million/jsx-runtime at every file you\nuse JSX (if you use an IDE it may appear as an unused variable).\nindex.jsx\nimport { h, Fragment } from 'million/jsx-runtime'; // This is required\n\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"classic\",\n        \"pragma\": \"h\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n","vite#Vite":"Bundlers that depend on esbuild, such as Vite, do not support or plan to implement jsx-runtime at the moment. To \"emulate\" the automatic runtime of Babel, Vite provides the jsxInject field, which automatically injects the import statement.\nEsbuild has a slightly different syntax than vite, and you should refer to the\ndocs for more information.\nindex.jsx\nconst HelloWorld = <p>Hello World</p>;\nvite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n    jsxInject: `import { h, Fragment } from 'million/jsx-runtime'`,\n  },\n});\n"}},"/docs/api/vnode/flags":{"title":"Flags","data":{"":"Syntax: Flags.FLAG_NAME\nExample: Flags.IGNORE_NODEFlags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated VNode is provided as the previous VNode\nduring a patch call.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a VNode.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Please hard replace me'],\n  Flags.REPLACE_NODE,\n);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Hello ', 'World!'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n"}},"/docs/api/m":{"title":"m()","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\nThe tagName is stored under the tag, attributes and properties are stored under props, and the children are stored under children.","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","classname-and-style-props-helpers#className and style props helpers":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are handled by default, but sometimes you need to attach SVG namespaces. SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","tovnode-ssr-helper#toVNode SSR helper":"The toVNode function converts an HTMLElement or Text or HTML string to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\n// HTML string\nconst vnode1 = toVNode('<div>Hello World</div>'); // holds <div>Hello World</div> in VNode form\n\n// HTMLElement\nconst el = document.createElement('div');\nel.textContent = 'Hello World';\nconst vnode2 = toVNode(el); // holds <div>Hello World</div> in VNode form\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/api/render":{"title":"render","data":{"":"Syntax: render(parentElement, vnode)\nExample: render(document.body, m('div'), m('div', undefined, ['Hello World']))The render function is a combonation of the patch() and createElement() functions. It takes a parent element and a vnode and returns a DOM node, and renders the vnode into the DOM.\nIf you're seeking more fine grained modification and customization, check out\nthe patch() function.\nHere's an example Counter app using render():\nimport { m, render } from 'million';\n\nlet seconds = 0;\n\nsetInterval(() => {\n  render(document.body, m('p', undefined, [`Time elapsed: ${seconds}`]));\n  seconds++;\n}, 1000);\n\n\nrender() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the parent DOM reference, and the second one is a Virtual DOM to render.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/createElement":{"title":"createElement","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/api/advanced/createElement":{"title":"createElement()","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/api/advanced/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVNode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","commit--effects#Commit & effects":"Sometimes, we want to do apply our own functionality across the entire VNode tree, yet we want to keep the API usage very simple. There are two areas where you can do this:\nVNode-by-VNode diffing: You can pass a callback into the commit parameter (see patch) syntax to deal with each VNode (excluding special diffing). You can construct a commit callback like this:\npatch(el, newVNode, oldVNode, [], (callback, data) => callback());\nYou can now access the callback, which you execute, and the data to get the context of the execution.\nOperation-by-Operation patching: Once diffing is completed, you can deal with effects, or DOM operations. Normally, effects are batched all at once, but if you want to modify this, you can check out custom patch functions. If you want to add your own custom effects, you can pass callbacks into the effects parameter like this:\npatch(el, newVNode, oldVNode, [() => console.log('Hello World!')]);\n\n\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport { m, useNode, useChildren, useProps, createElement } from 'million';\n\nconst diff = useNode([useChildren(), useProps()]);\n\nconst customPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\ncustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an implementation of a rudimentary virtual DOM with reference-based diffing of an existing el.\nimport { createElement } from 'million';\n\nconst useNodeReplace =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n    const data = {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n\n    commit(() => {\n      if (!newVNode) {\n        effects.push(() => el.remove());\n      } else if (oldVNode !== newVNode) {\n        effects.push(() => el.replaceWith(createElement(newVNode)));\n      }\n    }, data);\n\n    return data;\n  };\n"}},"/docs/api/advanced/flags":{"title":"Flags","data":{"":"Syntax: Flags.FLAG_NAME\nExample: Flags.IGNORE_NODEFlags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated VNode is provided as the previous VNode\nduring a patch call.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a VNode.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Please hard replace me'],\n  Flags.REPLACE_NODE,\n);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Hello ', 'World!'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n"}},"/docs/api/advanced/delta":{"title":"Delta","data":{"":"Syntax: Delta.OPERATION(index)\nExample: Delta.INSERT(0)Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the VNode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [\n  Delta.INSERT(0),\n  Delta.UPDATE(0),\n]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/api/advanced/schedule":{"title":"schedule()","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, diff, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/api/advanced/entity":{"title":"entity()","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a VNode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst customEntity = entity(data, () =>\n  m('div', { id: 'app' }, [data.message]),\n);\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/api/basics/render":{"title":"render()","data":{"":"Syntax: render(parentElement, vnode)\nExample: render(document.body, m('div'), m('div', undefined, ['Hello World']))The render function is a combonation of the patch() and createElement() functions. It takes a parent element and a vnode and returns a DOM node, and renders the vnode into the DOM.\nIf you're seeking more fine grained modification and customization, check out\nthe patch() function.\nHere's an example Counter app using render():\nimport { m, render } from 'million';\n\nlet seconds = 0;\n\nsetInterval(() => {\n  render(document.body, m('p', undefined, [`Time elapsed: ${seconds}`]));\n  seconds++;\n}, 1000);\n\n\nrender() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the parent DOM reference, and the second one is a Virtual DOM to render.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/basics/m":{"title":"m()","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\nThe tagName is stored under the tag, attributes and properties are stored under props, and the children are stored under children.","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","classname-and-style-props-helpers#className and style props helpers":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are handled by default, but sometimes you need to attach SVG namespaces. SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","tovnode-ssr-helper#toVNode SSR helper":"The toVNode function converts an HTMLElement or Text or HTML string to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\n// HTML string\nconst vnode1 = toVNode('<div>Hello World</div>'); // holds <div>Hello World</div> in VNode form\n\n// HTMLElement\nconst el = document.createElement('div');\nel.textContent = 'Hello World';\nconst vnode2 = toVNode(el); // holds <div>Hello World</div> in VNode form\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/tooling/using-jsx":{"title":"Using JSX","data":{"":"The following declaration style:\nconst HelloWorld = <p>Hello World</p>;\nis called JSX, and it is a syntax extension to JavaScript. Much like React, you can use JSX with Million.js to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces Million VNodes. Below, you can find how to integrate JSX in your own project.","babel#Babel":"\nWe recommend using the\nbabel-preset-million preset with Babel for\nJSX transforms. Babel can easily be used with other bundlers like Webpack, Parcel, or Rollup, or\nstandalone.\nAlternatively, you can manually configure your JSX transform using @babel/plugin-transform-react-jsx.There are two main ways to transform your data, so choose the one that fits your project best.","automatic-runtime-recommended#Automatic runtime (recommended)":"Million.js provides an automatic JSX transform option through under million/jsx-runtime. Babel, by default, uses classic runtime, so you will need to explicitly state that you want automatic runtime. Additionally, you will need to specify an import source. It is not necessary to explicity import million/jsx-runtime with the automatic runtime.index.jsx\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"automatic\",\n        \"importSource\": \"million\"\n      }\n    ]\n  ]\n}\n","classic-runtime#Classic runtime":"If the automatic runtime does not work for you, or you want more fine-grained control, you should use the classic runtime. You'll need to define the pragma and pragmaFrag fields with the imports from the million/jsx-runtime, as shown below.\nThis is often more cumbersome, as you'll need to import million/jsx-runtime at every file you\nuse JSX (if you use an IDE it may appear as an unused variable).\nindex.jsx\nimport { h, Fragment } from 'million/jsx-runtime'; // This is required\n\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"classic\",\n        \"pragma\": \"h\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n","vite#Vite":"Bundlers that depend on esbuild, such as Vite, do not support or plan to implement jsx-runtime at the moment. To \"emulate\" the automatic runtime of Babel, Vite provides the jsxInject field, which automatically injects the import statement.\nEsbuild has a slightly different syntax than vite, and you should refer to the\ndocs for more information.\nindex.jsx\nconst HelloWorld = <p>Hello World</p>;\nvite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n    jsxInject: `import { h, Fragment } from 'million/jsx-runtime'`,\n  },\n});\n"}},"/docs/tooling/compiler":{"title":"Compiler","data":{"":"Million.js is intended to be the Virtual DOM runtime for your application. It's primarily designed to be augmented by a compiler which can produce optimizations and code generation for Million.js. However, Million.js doesn't provide a compiler by default, as static analysis and code generation are difficult to pull off well without knowledge of the library (state, components, etc.).However, Million.js does provide example implementations for virtual node h functions to raw objects with vite-plugin-million.If you are considering writing a compiler for your Million.js library, consider taking a look at the implemenation of vite-plugin-million. Additionally, you should look into recast and ast-types, both great options for JavaScript AST traversal for static analysis."}},"/docs/tooling/ssg-ssr":{"title":"SSG/SSR","data":{"":"TestMillion.js is intended to be the Virtual DOM runtime for your application. It's primarily designed to be augmented by a compiler which can produce optimizations and code generation for Million.js. However, Million.js doesn't provide a compiler by default, as static analysis and code generation are difficult to pull off well without knowledge of the library (state, components, etc.).However, Million.js does provide example implementations for virtual node h functions to raw objects with vite-plugin-million.If you are considering writing a compiler for your Million.js library, consider taking a look at the implemenation of vite-plugin-million. Additionally, you should look into recast and ast-types, both great options for JavaScript AST traversal for static analysis."}}}